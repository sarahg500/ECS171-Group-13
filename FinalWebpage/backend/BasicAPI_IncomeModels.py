import pandas as pd
import numpy as np
import seaborn as sns
from numpy import array
from numpy import argmax
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder
import csv
import codecs
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
import seaborn as sns
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
from sklearn.linear_model import LinearRegression 
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from IPython.display import display
from sklearn.preprocessing import PolynomialFeatures
from sklearn.preprocessing import FunctionTransformer
import scipy 
from scipy.optimize import curve_fit


df = pd.read_csv('marketing_campaign.csv')

df.drop(df.index[[2233,239,339,192,21,1975,1806,1328]], inplace=True)  # Remove outliers
df = df.dropna() # Removing rows with missing values
df.drop(df[df.Marital_Status == "YOLO"].index, inplace=True)
df.drop(df[df.Marital_Status == "Absurd"].index, inplace=True)
df = df[df['Income'] <= 100000]



marital = pd.get_dummies(df['Marital_Status'], drop_first=True)
df = pd.concat([df, marital], axis=1)

education = pd.get_dummies(df['Education'], drop_first=True)
pd.concat([df, education], axis=1)


dfram = df.copy()
dfram = dfram.drop('ID', axis=1)
dfram = dfram.drop('Dt_Customer', axis=1)
dfram = dfram.drop('Recency', axis=1)
dfram['Year_Birth'] = dfram['Year_Birth'].map(lambda a: 2015-a)
dfram.head()

# this part is for recording the min and max for specific columns, for input scaling purpsoes
inc_max = dfram['Income'].max()
inc_min = dfram['Income'].min()

#wine products
wine_max = dfram['MntWines'].max()
wine_min = dfram['MntWines'].min()

#sweet prodcuts
sp_max = dfram['MntSweetProducts'].max()
sp_min = dfram['MntSweetProducts'].min()

#meat products
meat_max = dfram['MntMeatProducts'].max()
meat_min = dfram['MntMeatProducts'].min()

#fish products
fish_max = dfram['MntFishProducts'].max()
fish_min = dfram['MntFishProducts'].min()

#fruit products
fruit_max = dfram['MntFruits'].max()
fruit_min = dfram['MntFruits'].min()

#gold products
gold_max = dfram['MntGoldProds'].max()
gold_min = dfram['MntGoldProds'].min()

dfram = dfram.drop(columns = ['Education','Marital_Status'])
scaler = MinMaxScaler()
scaled = scaler.fit_transform(dfram) # same thing as the one on the bottom but usign it for finding inverse
dfram[list(dfram.columns.values)] = scaler.fit_transform(dfram[list(dfram.columns.values)])

# Polynomial Regression Function
def PolynomialRegression(productName, X, y, X_test, y_test, deg=2, figsize=7):
    poly = PolynomialFeatures(degree=deg, include_bias=False)
    
 
    X_poly = poly.fit_transform(np.asarray(X).reshape(-1, 1)) # could have use np.asarray(X) or X.values
    X_testpol = poly.fit_transform(np.asarray(X_test).reshape(-1, 1))
    # This exactly implements the above formula
    polyReg = LinearRegression().fit(X_poly, y.values.reshape(-1, 1)) 
    
    # Printing Coefficients
    coef = pd.DataFrame(polyReg.coef_, columns=[f'b{i+1}' for i in range(deg)])
    coef.insert(loc=0, column='b0', value=polyReg.intercept_)
    coef = coef.style.format("{:10,.10f}") # Comment this out to not suppressing the scientific notation
    # display(coef)
    
    #### Plotting ####
    # plt.figure(figsize=(figsize, figsize))
    # plt.scatter(X, y, color='k', alpha=.5)
    # plt.plot(X, polyReg.predict(X_poly), color='tab:blue', alpha=.5)

    # plt.xlabel("Income")
    # plt.ylabel(productName)
    # plt.legend([f'Degree-{deg} Polynomial Regression', 'Training data'])
    # print("MSE Train: ", mean_squared_error(np.asarray(y).reshape(-1,1), polyReg.predict(X_poly)))
    # print("MSE Test: ", mean_squared_error(np.asarray(y_test).reshape(-1,1), polyReg.predict(X_testpol)))
    
    # plt.show()
    

def trainAndTest(dataframe, productName):
    dfram = dataframe.sort_values(by='Income')
    train, test = train_test_split(dfram, test_size=0.2, random_state=21)
    X = dfram['Income']
    y = dfram[productName]

    train = train.sort_values(by='Income')
    test = test.sort_values(by='Income')
    X_train, X_test = train['Income'], test['Income']
    y_train, y_test = train[productName], test[productName]
    PolynomialRegression(productName,X_train, y_train, X_test, y_test, deg=2) 
    PolynomialRegression(productName,X_train, y_train, X_test, y_test, deg=3) 
    
    # The values generated by the following line of code are the constants used in the expo functions   
    # print(scipy.optimize.curve_fit(lambda t,a,b: a*np.exp(b*t),  X_train,  y_train, p0=(0.000001, 1e-4))) #p0 is a starting point


trainAndTest(dfram, 'MntWines')
trainAndTest(dfram, 'MntSweetProducts')
trainAndTest(dfram, 'MntMeatProducts')
trainAndTest(dfram, 'MntFishProducts')
trainAndTest(dfram, 'MntGoldProds')
trainAndTest(dfram, 'MntFruits')


# These expo functions will return the un-normalized amount
def expo_fishproducts(X):
    return  0.01850421 * np.exp(3.52844529*X)

def expo_meatproducts(X):
    return  0.01222817 * np.exp(4.38457758*X)

def expo_sweetproducts(X):
    return  0.01557514 * np.exp(3.69997545*X)

def expo_wine(X):
    return  0.03253435 * np.exp(3.25207678*X) 

def expo_gold(X):
    return  0.05340341 * np.exp(2.1339927*X) 

def expo_fruit(X):
    return  0.01692545 * np.exp(3.57243742*X) 
    
# note that these output are based on how much a person is expected to buy in two years 
def ui_api(income):

    res = {}
    if income < 0:
        return -1

    #normalizing income 
    income = (income-inc_min)/(inc_max-inc_min)
    
    # getting result
    res_wine = expo_wine(income)
    res_sweetproducts = expo_sweetproducts(income)
    res_meat = expo_meatproducts(income)
    res_fish = expo_fishproducts(income)
    res_gold = expo_gold(income)
    res_fruit = expo_fruit(income)
    
    # unormalize
    out_wine = res_wine*(wine_max-wine_min) + wine_min
    out_sweetproducts = res_sweetproducts*(sp_max-sp_min) + sp_min
    out_meat = res_meat * (meat_max-meat_min) + meat_min
    out_fish = res_fish * (fish_max - fish_min) + fish_min
    out_fruit = res_fruit * (fruit_max - fruit_min) + fruit_min
    out_gold = res_gold * (gold_max - gold_min) + gold_min
    
    res['wine'] = out_wine
    res['sweetprod']= out_sweetproducts
    res['meat'] = out_meat
    res['fish'] = out_fish
    res['gold'] = out_gold
    res['fruit'] = out_fruit

    return res
